<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MetaInject.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">meta-inject-plugin</a> &gt; <a href="index.source.html" class="el_package">org.pentaho.di.trans.steps.metainject</a> &gt; <span class="el_source">MetaInject.java</span></div><h1>MetaInject.java</h1><pre class="source lang-java linenums">/*! ******************************************************************************
 *
 * Pentaho Data Integration
 *
 * Copyright (C) 2002-2016 by Pentaho : http://www.pentaho.com
 *
 *******************************************************************************
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 ******************************************************************************/

package org.pentaho.di.trans.steps.metainject;

import org.pentaho.di.core.Const;
import org.pentaho.di.core.Result;
import org.pentaho.di.core.RowMetaAndData;
import org.pentaho.di.core.RowSet;
import org.pentaho.di.core.exception.KettleException;
import org.pentaho.di.core.exception.KettleStepException;
import org.pentaho.di.core.exception.KettleValueException;
import org.pentaho.di.core.injection.bean.BeanInjectionInfo;
import org.pentaho.di.core.injection.bean.BeanInjector;
import org.pentaho.di.core.row.RowMetaInterface;
import org.pentaho.di.core.row.ValueMetaInterface;
import org.pentaho.di.core.vfs.KettleVFS;
import org.pentaho.di.core.xml.XMLHandler;
import org.pentaho.di.i18n.BaseMessages;
import org.pentaho.di.trans.RowProducer;
import org.pentaho.di.trans.Trans;
import org.pentaho.di.trans.TransMeta;
import org.pentaho.di.trans.TransStoppedListener;
import org.pentaho.di.trans.step.BaseStep;
import org.pentaho.di.trans.step.RowAdapter;
import org.pentaho.di.trans.step.StepDataInterface;
import org.pentaho.di.trans.step.StepInjectionMetaEntry;
import org.pentaho.di.trans.step.StepInterface;
import org.pentaho.di.trans.step.StepMeta;
import org.pentaho.di.trans.step.StepMetaInjectionInterface;
import org.pentaho.di.trans.step.StepMetaInterface;

import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

/**
 * Read a simple CSV file Just output Strings found in the file...
 *
 * @author Matt
 * @since 2007-07-05
 */
public class MetaInject extends BaseStep implements StepInterface {
<span class="fc" id="L71">  private static Class&lt;?&gt; PKG = MetaInject.class; // for i18n purposes, needed</span>
                                                  // by Translator2!!

  private MetaInjectMeta meta;
  private MetaInjectData data;

  public MetaInject( StepMeta stepMeta, StepDataInterface stepDataInterface, int copyNr, TransMeta transMeta,
      Trans trans ) {
<span class="fc" id="L79">    super( stepMeta, stepDataInterface, copyNr, transMeta, trans );</span>
<span class="fc" id="L80">  }</span>

  public boolean processRow( StepMetaInterface smi, StepDataInterface sdi ) throws KettleException {
<span class="fc" id="L83">    meta = (MetaInjectMeta) smi;</span>
<span class="fc" id="L84">    data = (MetaInjectData) sdi;</span>

    // Read the data from all input steps and keep it in memory...
    // Skip the step from which we stream data. Keep that available for runtime action.
    //
<span class="fc" id="L89">    data.rowMap = new HashMap&lt;String, List&lt;RowMetaAndData&gt;&gt;();</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">    for ( String prevStepName : getTransMeta().getPrevStepNames( getStepMeta() ) ) {</span>
      // Don't read from the streaming source step
      //
<span class="pc bpc" id="L93" title="3 of 4 branches missed.">      if ( !data.streaming || !prevStepName.equalsIgnoreCase( data.streamingSourceStepname ) ) {</span>
<span class="fc" id="L94">        List&lt;RowMetaAndData&gt; list = new ArrayList&lt;RowMetaAndData&gt;();</span>
<span class="fc" id="L95">        RowSet rowSet = findInputRowSet( prevStepName );</span>
<span class="fc" id="L96">        Object[] row = getRowFrom( rowSet );</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">        while ( row != null ) {</span>
<span class="fc" id="L98">          RowMetaAndData rd = new RowMetaAndData();</span>
<span class="fc" id="L99">          rd.setRowMeta( rowSet.getRowMeta() );</span>
<span class="fc" id="L100">          rd.setData( row );</span>
<span class="fc" id="L101">          list.add( rd );</span>

<span class="fc" id="L103">          row = getRowFrom( rowSet );</span>
<span class="fc" id="L104">        }</span>
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">        if ( !list.isEmpty() ) {</span>
<span class="fc" id="L106">          data.rowMap.put( prevStepName, list );</span>
        }
      }
    }

<span class="fc" id="L111">    List&lt;StepMeta&gt; steps = data.transMeta.getSteps();</span>
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">    for ( Map.Entry&lt;String, StepMetaInterface&gt; en : data.stepInjectionMetasMap.entrySet() ) {</span>
<span class="nc" id="L113">      newInjection( en.getKey(), en.getValue() );</span>
<span class="nc" id="L114">      en.getValue().searchInfoAndTargetSteps( steps );</span>
<span class="nc" id="L115">    }</span>

<span class="fc bfc" id="L117" title="All 2 branches covered.">    for ( String targetStepName : data.stepInjectionMap.keySet() ) {</span>
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">      if ( !data.stepInjectionMetasMap.containsKey( targetStepName ) ) {</span>
<span class="fc" id="L119">        oldInjection( targetStepName );</span>
<span class="fc" id="L120">        StepMeta targetStep = StepMeta.findStep( steps, targetStepName );</span>
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">        if ( targetStep != null ) {</span>
<span class="nc" id="L122">          targetStep.getStepMetaInterface().searchInfoAndTargetSteps( steps );</span>
        }
      }
<span class="fc" id="L125">    }</span>

<span class="fc bfc" id="L127" title="All 2 branches covered.">    if ( !meta.isNoExecution() ) {</span>
      // Now we can execute this modified transformation metadata.
      //
<span class="fc" id="L130">      final Trans injectTrans = createInjectTrans();</span>
<span class="fc" id="L131">      injectTrans.setMetaStore( getMetaStore() );</span>
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">      if ( getTrans().getParentJob() != null ) {</span>
<span class="nc" id="L133">        injectTrans.setParentJob( getTrans().getParentJob() ); // See PDI-13224</span>
      }
<span class="fc" id="L135">      getTrans().addTransStoppedListener( new TransStoppedListener() {</span>
        public void transStopped( Trans parentTrans ) {
<span class="nc" id="L137">          injectTrans.stopAll();</span>
<span class="nc" id="L138">        }</span>
      } );
<span class="fc" id="L140">      injectTrans.prepareExecution( null );</span>

      // See if we need to stream some data over...
      //
<span class="fc" id="L144">      RowProducer rowProducer = null;</span>
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">      if ( data.streaming ) {</span>
<span class="nc" id="L146">        rowProducer = injectTrans.addRowProducer( data.streamingTargetStepname, 0 );</span>
      }

      // Finally, add the mapping transformation to the active sub-transformations
      // map in the parent transformation
      //
<span class="fc" id="L152">      getTrans().getActiveSubtransformations().put( getStepname(), injectTrans );</span>

<span class="pc bpc" id="L154" title="1 of 2 branches missed.">      if ( !Const.isEmpty( meta.getSourceStepName() ) ) {</span>
<span class="nc" id="L155">        StepInterface stepInterface = injectTrans.getStepInterface( meta.getSourceStepName(), 0 );</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">        if ( stepInterface == null ) {</span>
<span class="nc" id="L157">          throw new KettleException( &quot;Unable to find step '&quot; + meta.getSourceStepName() + &quot;' to read from.&quot; );</span>
        }
<span class="nc" id="L159">        stepInterface.addRowListener( new RowAdapter() {</span>
          @Override
          public void rowWrittenEvent( RowMetaInterface rowMeta, Object[] row ) throws KettleStepException {
            // Just pass along the data as output of this step...
            //
<span class="nc" id="L164">            MetaInject.this.putRow( rowMeta, row );</span>
<span class="nc" id="L165">          }</span>
        } );
      }

<span class="fc" id="L169">      injectTrans.startThreads();</span>

<span class="pc bpc" id="L171" title="1 of 2 branches missed.">      if ( data.streaming ) {</span>
        // Deplete all the rows from the parent transformation into the modified transformation
        //
<span class="nc" id="L174">        RowSet rowSet = findInputRowSet( data.streamingSourceStepname );</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">        if ( rowSet == null ) {</span>
<span class="nc" id="L176">          throw new KettleException( &quot;Unable to find step '&quot; + data.streamingSourceStepname + &quot;' to stream data from&quot; );</span>
        }
<span class="nc" id="L178">        Object[] row = getRowFrom( rowSet );</span>
<span class="nc bnc" id="L179" title="All 4 branches missed.">        while ( row != null &amp;&amp; !isStopped() ) {</span>
<span class="nc" id="L180">          rowProducer.putRow( rowSet.getRowMeta(), row );</span>
<span class="nc" id="L181">          row = getRowFrom( rowSet );</span>
        }
<span class="nc" id="L183">        rowProducer.finished();</span>
      }

      // Wait until the child transformation finished processing...
      //
<span class="pc bpc" id="L188" title="5 of 6 branches missed.">      while ( !injectTrans.isFinished() &amp;&amp; !injectTrans.isStopped() &amp;&amp; !isStopped() ) {</span>
<span class="nc" id="L189">        copyResult( injectTrans );</span>

        // Wait a little bit.
        try {
<span class="nc" id="L193">          Thread.sleep( 50 );</span>
<span class="nc" id="L194">        } catch ( Exception e ) {</span>
          // Ignore errors
<span class="nc" id="L196">        }</span>
      }
<span class="fc" id="L198">      copyResult( injectTrans );</span>
<span class="fc" id="L199">      waitUntilFinished( injectTrans );</span>
    }

    // let the transformation complete it's execution to allow for any customizations to MDI to happen in the init methods of steps
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">    if ( log.isDetailed() ) {</span>
<span class="nc" id="L204">      logDetailed( &quot;XML of transformation after injection: &quot; + data.transMeta.getXML() );</span>
    }
<span class="fc" id="L206">    String targetFile = environmentSubstitute( meta.getTargetFile() );</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">    if ( !Const.isEmpty( targetFile ) ) {</span>
<span class="nc" id="L208">      writeInjectedKtr( targetFile );</span>
    }

    // All done!

<span class="fc" id="L213">    setOutputDone();</span>

<span class="fc" id="L215">    return false;</span>
  }

  void waitUntilFinished( Trans injectTrans ) {
<span class="fc" id="L219">    injectTrans.waitUntilFinished();</span>
<span class="fc" id="L220">  }</span>

  Trans createInjectTrans() {
<span class="fc" id="L223">    return new Trans( data.transMeta, this );</span>
  }

  private void writeInjectedKtr( String targetFile ) throws KettleException {
<span class="nc" id="L227">    OutputStream os = null;</span>
    try {
<span class="nc" id="L229">      os = KettleVFS.getOutputStream( targetFile, false );</span>
<span class="nc" id="L230">      os.write( XMLHandler.getXMLHeader().getBytes( Const.XML_ENCODING ) );</span>
<span class="nc" id="L231">      os.write( data.transMeta.getXML().getBytes( Const.XML_ENCODING ) );</span>
<span class="nc" id="L232">    } catch ( IOException e ) {</span>
<span class="nc" id="L233">      throw new KettleException( &quot;Unable to write target file (ktr after injection) to file '&quot; + targetFile + &quot;'&quot;,</span>
        e );
    } finally {
<span class="nc bnc" id="L236" title="All 4 branches missed.">      if ( os != null ) {</span>
        try {
<span class="nc" id="L238">          os.close();</span>
<span class="nc" id="L239">        } catch ( Exception e ) {</span>
<span class="nc" id="L240">          throw new KettleException( e );</span>
<span class="nc" id="L241">        }</span>
      }
    }
<span class="nc" id="L244">  }</span>

  private void newInjection( String targetStep, StepMetaInterface targetStepMeta ) throws KettleException {
<span class="nc bnc" id="L247" title="All 2 branches missed.">    if ( log.isDetailed() ) {</span>
<span class="nc" id="L248">      logDetailed( &quot;Handing step '&quot; + targetStep + &quot;' injection!&quot; );</span>
    }
<span class="nc" id="L250">    BeanInjectionInfo injectionInfo = new BeanInjectionInfo( targetStepMeta.getClass() );</span>
<span class="nc" id="L251">    BeanInjector injector = new BeanInjector( injectionInfo );</span>

    // Collect all the metadata for this target step...
    //
<span class="nc" id="L255">    Map&lt;TargetStepAttribute, SourceStepField&gt; targetMap = meta.getTargetSourceMapping();</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">    for ( TargetStepAttribute target : targetMap.keySet() ) {</span>
<span class="nc" id="L257">      SourceStepField source = targetMap.get( target );</span>

<span class="nc bnc" id="L259" title="All 2 branches missed.">      if ( target.getStepname().equalsIgnoreCase( targetStep ) ) {</span>
        // This is the step to collect data for...
        // We also know which step to read the data from. (source)
        //
<span class="nc" id="L263">        List&lt;RowMetaAndData&gt; rows = data.rowMap.get( source.getStepname() );</span>
<span class="nc bnc" id="L264" title="All 4 branches missed.">        if ( rows != null &amp;&amp; !rows.isEmpty() ) {</span>
          // Which metadata key is this referencing? Find the attribute key in the metadata entries...
          //
<span class="nc bnc" id="L267" title="All 2 branches missed.">          if ( injector.hasProperty( targetStepMeta, target.getAttributeKey() ) ) {</span>
            // target step has specified key
<span class="nc" id="L269">            boolean skip = false;</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">            for ( RowMetaAndData r : rows ) {</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">              if ( r.getRowMeta().indexOfValue( source.getField() ) &lt; 0 ) {</span>
<span class="nc" id="L272">                logError( BaseMessages.getString( PKG, &quot;MetaInject.SourceFieldIsNotDefined.Message&quot;, source.getField(),</span>
<span class="nc" id="L273">                    getTransMeta().getName() ) );</span>
                // source step doesn't contain specified field
<span class="nc" id="L275">                skip = true;</span>
              }
<span class="nc" id="L277">            }</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">            if ( !skip ) {</span>
              // specified field exist - need to inject
<span class="nc" id="L280">              injector.setProperty( targetStepMeta, target.getAttributeKey(), rows, source.getField() );</span>
            }
<span class="nc" id="L282">          } else {</span>
            // target step doesn't have specified key - just report but don't fail like in 6.0 (BACKLOG-6753)
<span class="nc" id="L284">            logError( BaseMessages.getString( PKG, &quot;MetaInject.TargetKeyIsNotDefined.Message&quot;, target.getAttributeKey(),</span>
<span class="nc" id="L285">                getTransMeta().getName() ) );</span>
          }
        }
      }
<span class="nc" id="L289">    }</span>
<span class="nc" id="L290">  }</span>

  private void oldInjection( String targetStep ) throws KettleException {

<span class="pc bpc" id="L294" title="1 of 2 branches missed.">    if ( log.isDetailed() ) {</span>
<span class="nc" id="L295">      logDetailed( &quot;Handing step '&quot; + targetStep + &quot;' injection!&quot; );</span>
    }

    // This is the injection interface:
    //
<span class="fc" id="L300">    StepMetaInjectionInterface injectionInterface = data.stepInjectionMap.get( targetStep );</span>

    // This is the injection description:
    //
<span class="fc" id="L304">    List&lt;StepInjectionMetaEntry&gt; metadataEntries = injectionInterface.getStepInjectionMetadataEntries();</span>

    // Create a new list of metadata injection entries...
    //
<span class="fc" id="L308">    List&lt;StepInjectionMetaEntry&gt; inject = new ArrayList&lt;StepInjectionMetaEntry&gt;();</span>

    // Collect all the metadata for this target step...
    //
<span class="fc" id="L312">    Map&lt;TargetStepAttribute, SourceStepField&gt; targetMap = meta.getTargetSourceMapping();</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">    for ( TargetStepAttribute target : targetMap.keySet() ) {</span>
<span class="fc" id="L314">      SourceStepField source = targetMap.get( target );</span>

<span class="pc bpc" id="L316" title="1 of 2 branches missed.">      if ( target.getStepname().equalsIgnoreCase( targetStep ) ) {</span>
        // This is the step to collect data for...
        // We also know which step to read the data from. (source)
        //
<span class="fc" id="L320">        List&lt;RowMetaAndData&gt; rows = data.rowMap.get( source.getStepname() );</span>
<span class="pc bpc" id="L321" title="2 of 4 branches missed.">        if ( rows != null &amp;&amp; rows.size() &gt; 0 ) {</span>
          // Which metadata key is this referencing? Find the attribute key in the metadata entries...
          //
<span class="fc" id="L324">          StepInjectionMetaEntry entry = findMetaEntry( metadataEntries, target.getAttributeKey() );</span>
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">          if ( entry != null ) {</span>
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">            if ( !target.isDetail() ) {</span>
<span class="nc" id="L327">              setEntryValueIfFieldExists( entry, rows.get( 0 ), source );</span>
<span class="nc" id="L328">              inject.add( entry );</span>
            } else {
              // We are going to pass this entry N times for N target mappings
              // As such, we have to see if it's already in the injection list...
              //
<span class="fc" id="L333">              StepInjectionMetaEntry metaEntries = findMetaEntry( inject, entry.getKey() );</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">              if ( metaEntries == null ) {</span>

<span class="fc" id="L336">                StepInjectionMetaEntry rootEntry = findDetailRootEntry( metadataEntries, entry );</span>

                // Inject an empty copy
                //
<span class="fc" id="L340">                metaEntries = rootEntry.clone();</span>
<span class="fc" id="L341">                metaEntries.setDetails( new ArrayList&lt;StepInjectionMetaEntry&gt;() );</span>
<span class="fc" id="L342">                inject.add( metaEntries );</span>

                // We also need to pre-populate the whole grid: X rows by Y attributes
                //
<span class="fc" id="L346">                StepInjectionMetaEntry metaEntry = rootEntry.getDetails().get( 0 );</span>

<span class="fc bfc" id="L348" title="All 2 branches covered.">                for ( int i = 0; i &lt; rows.size(); i++ ) {</span>
<span class="fc" id="L349">                  StepInjectionMetaEntry metaCopy = metaEntry.clone();</span>
<span class="fc" id="L350">                  metaEntries.getDetails().add( metaCopy );</span>
<span class="fc" id="L351">                  metaCopy.setDetails( new ArrayList&lt;StepInjectionMetaEntry&gt;() );</span>

<span class="fc bfc" id="L353" title="All 2 branches covered.">                  for ( StepInjectionMetaEntry me : metaEntry.getDetails() ) {</span>
<span class="fc" id="L354">                    StepInjectionMetaEntry meCopy = me.clone();</span>
<span class="fc" id="L355">                    metaCopy.getDetails().add( meCopy );</span>
<span class="fc" id="L356">                  }</span>
                }

                // From now on we can simply refer to the correct X,Y coordinate.
<span class="fc" id="L360">              } else {</span>
<span class="fc" id="L361">                StepInjectionMetaEntry rootEntry = findDetailRootEntry( inject, metaEntries );</span>
<span class="fc" id="L362">                metaEntries = rootEntry;</span>
              }

<span class="fc bfc" id="L365" title="All 2 branches covered.">              for ( int i = 0; i &lt; rows.size(); i++ ) {</span>
<span class="fc" id="L366">                RowMetaAndData row = rows.get( i );</span>
                try {
<span class="fc" id="L368">                  List&lt;StepInjectionMetaEntry&gt; rowEntries = metaEntries.getDetails().get( i ).getDetails();</span>

<span class="fc bfc" id="L370" title="All 2 branches covered.">                  for ( StepInjectionMetaEntry rowEntry : rowEntries ) {</span>
                    // We have to look up the sources for these targets again in the target-2-source mapping
                    // That is because we only want handle this as few times as possible...
                    //
<span class="fc" id="L374">                    SourceStepField detailSource = findDetailSource( targetMap, targetStep, rowEntry.getKey() );</span>
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">                    if ( detailSource != null ) {</span>
<span class="fc" id="L376">                      setEntryValueIfFieldExists( rowEntry, row, detailSource );</span>
                    } else {
<span class="nc bnc" id="L378" title="All 2 branches missed.">                      if ( log.isDetailed() ) {</span>
<span class="nc" id="L379">                        logDetailed( &quot;No detail source found for key: &quot; + rowEntry.getKey() + &quot; and target step: &quot;</span>
                            + targetStep );
                      }
                    }
<span class="fc" id="L383">                  }</span>
<span class="nc" id="L384">                } catch ( Exception e ) {</span>
<span class="nc" id="L385">                  throw new KettleException( &quot;Unexpected error occurred while injecting metadata&quot;, e );</span>
<span class="fc" id="L386">                }</span>
              }

<span class="pc bpc" id="L389" title="1 of 2 branches missed.">              if ( log.isDetailed() ) {</span>
<span class="nc" id="L390">                logDetailed( &quot;injected entry: &quot; + entry );</span>
              }
<span class="fc" id="L392">            }</span>
            // End of TopLevel/Detail if block
          } else {
<span class="nc bnc" id="L395" title="All 2 branches missed.">            if ( log.isDetailed() ) {</span>
<span class="nc" id="L396">              logDetailed( &quot;entry not found: &quot; + target.getAttributeKey() );</span>
            }
          }
<span class="fc" id="L399">        } else {</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">          if ( log.isDetailed() ) {</span>
<span class="nc" id="L401">            logDetailed( &quot;No rows found for source step: &quot; + source.getStepname() );</span>
          }
        }
      }
<span class="fc" id="L405">    }</span>

    // Inject the metadata into the step!
    //
<span class="fc" id="L409">    injectionInterface.injectStepMetadataEntries( inject );</span>
<span class="fc" id="L410">  }</span>

  private void copyResult( Trans trans ) {
<span class="fc" id="L413">    Result result = trans.getResult();</span>
<span class="fc" id="L414">    setLinesInput( result.getNrLinesInput() );</span>
<span class="fc" id="L415">    setLinesOutput( result.getNrLinesOutput() );</span>
<span class="fc" id="L416">    setLinesRead( result.getNrLinesRead() );</span>
<span class="fc" id="L417">    setLinesWritten( result.getNrLinesWritten() );</span>
<span class="fc" id="L418">    setLinesUpdated( result.getNrLinesUpdated() );</span>
<span class="fc" id="L419">    setLinesRejected( result.getNrLinesRejected() );</span>
<span class="fc" id="L420">    setErrors( result.getNrErrors() );</span>
<span class="fc" id="L421">  }</span>

  private StepInjectionMetaEntry findDetailRootEntry( List&lt;StepInjectionMetaEntry&gt; metadataEntries,
      StepInjectionMetaEntry entry ) {
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">    for ( StepInjectionMetaEntry rowsEntry : metadataEntries ) {</span>
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">      for ( StepInjectionMetaEntry rowEntry : rowsEntry.getDetails() ) {</span>
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">        for ( StepInjectionMetaEntry detailEntry : rowEntry.getDetails() ) {</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">          if ( detailEntry.equals( entry ) ) {</span>
<span class="fc" id="L429">            return rowsEntry;</span>
          }
<span class="fc" id="L431">        }</span>
<span class="nc" id="L432">      }</span>
<span class="nc" id="L433">    }</span>
<span class="nc" id="L434">    return null;</span>
  }

  private SourceStepField findDetailSource( Map&lt;TargetStepAttribute, SourceStepField&gt; targetMap, String targetStep,
      String key ) {
<span class="fc" id="L439">    return targetMap.get( new TargetStepAttribute( targetStep, key, true ) );</span>
  }

  private StepInjectionMetaEntry findMetaEntry( List&lt;StepInjectionMetaEntry&gt; metadataEntries, String attributeKey ) {
<span class="fc bfc" id="L443" title="All 2 branches covered.">    for ( StepInjectionMetaEntry entry : metadataEntries ) {</span>
<span class="fc bfc" id="L444" title="All 2 branches covered.">      if ( entry.getKey().equals( attributeKey ) ) {</span>
<span class="fc" id="L445">        return entry;</span>
      }
<span class="fc" id="L447">      entry = findMetaEntry( entry.getDetails(), attributeKey );</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">      if ( entry != null ) {</span>
<span class="fc" id="L449">        return entry;</span>
      }
<span class="fc" id="L451">    }</span>
<span class="fc" id="L452">    return null;</span>
  }

  /**
   * package-local visibility for testing purposes
   */
  void setEntryValueIfFieldExists( StepInjectionMetaEntry entry, RowMetaAndData row, SourceStepField source )
      throws KettleValueException {
<span class="fc" id="L460">    RowMetaInterface rowMeta = row.getRowMeta();</span>
<span class="fc bfc" id="L461" title="All 2 branches covered.">    if ( rowMeta.indexOfValue( source.getField() ) &lt; 0 ) {</span>
<span class="fc" id="L462">      return;</span>
    }
<span class="fc" id="L464">    setEntryValue( entry, row, source );</span>
<span class="fc" id="L465">  }</span>

  /**
   * package-local visibility for testing purposes
   */
  static void setEntryValue( StepInjectionMetaEntry entry, RowMetaAndData row, SourceStepField source )
    throws KettleValueException {
    // A standard attribute, a single row of data...
    //
<span class="fc" id="L474">    Object value = null;</span>
<span class="pc bpc" id="L475" title="1 of 7 branches missed.">    switch ( entry.getValueType() ) {</span>
      case ValueMetaInterface.TYPE_STRING:
<span class="fc" id="L477">        value = row.getString( source.getField(), null );</span>
<span class="fc" id="L478">        break;</span>
      case ValueMetaInterface.TYPE_BOOLEAN:
<span class="fc" id="L480">        value = row.getBoolean( source.getField(), false );</span>
<span class="fc" id="L481">        break;</span>
      case ValueMetaInterface.TYPE_INTEGER:
<span class="fc" id="L483">        value = row.getInteger( source.getField(), 0L );</span>
<span class="fc" id="L484">        break;</span>
      case ValueMetaInterface.TYPE_NUMBER:
<span class="fc" id="L486">        value = row.getNumber( source.getField(), 0.0D );</span>
<span class="fc" id="L487">        break;</span>
      case ValueMetaInterface.TYPE_DATE:
<span class="fc" id="L489">        value = row.getDate( source.getField(), null );</span>
<span class="fc" id="L490">        break;</span>
      case ValueMetaInterface.TYPE_BIGNUMBER:
<span class="fc" id="L492">        value = row.getBigNumber( source.getField(), null );</span>
<span class="fc" id="L493">        break;</span>
      default:
        break;
    }
<span class="fc" id="L497">    entry.setValue( value );</span>
<span class="fc" id="L498">  }</span>

  public boolean init( StepMetaInterface smi, StepDataInterface sdi ) {
<span class="fc" id="L501">    meta = (MetaInjectMeta) smi;</span>
<span class="fc" id="L502">    data = (MetaInjectData) sdi;</span>

<span class="pc bpc" id="L504" title="1 of 2 branches missed.">    if ( super.init( smi, sdi ) ) {</span>
      try {
<span class="fc" id="L506">        meta.actualizeMetaInjectMapping();</span>
<span class="fc" id="L507">        data.transMeta = loadTransformationMeta();</span>
<span class="fc" id="L508">        data.transMeta.copyVariablesFrom( this );</span>
<span class="fc" id="L509">        data.transMeta.copyParametersFrom( this.getTransMeta() );</span>
<span class="fc" id="L510">        checkSoureStepsAvailability();</span>
<span class="fc" id="L511">        checkTargetStepsAvailability();</span>
        // Get a mapping between the step name and the injection...
        //
        // Get new injection info
<span class="fc" id="L515">        data.stepInjectionMetasMap = new HashMap&lt;String, StepMetaInterface&gt;();</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">        for ( StepMeta stepMeta : data.transMeta.getUsedSteps() ) {</span>
<span class="fc" id="L517">          StepMetaInterface meta = stepMeta.getStepMetaInterface();</span>
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">          if ( BeanInjectionInfo.isInjectionSupported( meta.getClass() ) ) {</span>
<span class="nc" id="L519">            data.stepInjectionMetasMap.put( stepMeta.getName(), meta );</span>
          }
<span class="fc" id="L521">        }</span>
        // Get old injection info
<span class="fc" id="L523">        data.stepInjectionMap = new HashMap&lt;String, StepMetaInjectionInterface&gt;();</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">        for ( StepMeta stepMeta : data.transMeta.getUsedSteps() ) {</span>
<span class="fc" id="L525">          StepMetaInjectionInterface injectionInterface =</span>
<span class="fc" id="L526">              stepMeta.getStepMetaInterface().getStepMetaInjectionInterface();</span>
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">          if ( injectionInterface != null ) {</span>
<span class="fc" id="L528">            data.stepInjectionMap.put( stepMeta.getName(), injectionInterface );</span>
          }
<span class="fc" id="L530">        }</span>

        // See if we need to stream data from a specific step into the template
        //
<span class="pc bpc" id="L534" title="3 of 4 branches missed.">        if ( meta.getStreamSourceStep() != null &amp;&amp; !Const.isEmpty( meta.getStreamTargetStepname() ) ) {</span>
<span class="nc" id="L535">          data.streaming = true;</span>
<span class="nc" id="L536">          data.streamingSourceStepname = meta.getStreamSourceStep().getName();</span>
<span class="nc" id="L537">          data.streamingTargetStepname = meta.getStreamTargetStepname();</span>
        }

<span class="fc" id="L540">        return true;</span>
<span class="nc" id="L541">      } catch ( Exception e ) {</span>
<span class="nc" id="L542">        logError( BaseMessages.getString( PKG, &quot;MetaInject.BadEncoding.Message&quot; ), e );</span>
<span class="nc" id="L543">        return false;</span>
      }
    }

<span class="nc" id="L547">    return false;</span>
  }

  private void checkTargetStepsAvailability() {
<span class="fc" id="L551">    Set&lt;String&gt; existedStepNames = convertToUpperCaseSet( data.transMeta.getStepNames() );</span>
<span class="fc" id="L552">    Map&lt;TargetStepAttribute, SourceStepField&gt; targetMap = meta.getTargetSourceMapping();</span>
<span class="fc" id="L553">    Set&lt;TargetStepAttribute&gt; unavailableTargetSteps = getUnavailableTargetSteps( targetMap, data.transMeta );</span>
<span class="fc" id="L554">    Set&lt;String&gt; alreadyMarkedSteps = new HashSet&lt;String&gt;();</span>
<span class="pc bpc" id="L555" title="1 of 2 branches missed.">    for ( TargetStepAttribute currentTarget : unavailableTargetSteps ) {</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">      if ( alreadyMarkedSteps.contains( currentTarget.getStepname() ) ) {</span>
<span class="nc" id="L557">        continue;</span>
      }
<span class="nc" id="L559">      alreadyMarkedSteps.add( currentTarget.getStepname() );</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">      if ( existedStepNames.contains( currentTarget.getStepname().toUpperCase() ) ) {</span>
<span class="nc" id="L561">        logError( BaseMessages.getString( PKG, &quot;MetaInject.TargetStepIsNotUsed.Message&quot;, currentTarget.getStepname(),</span>
<span class="nc" id="L562">            data.transMeta.getName() ) );</span>
      } else {
<span class="nc" id="L564">        logError( BaseMessages.getString( PKG, &quot;MetaInject.TargetStepIsNotDefined.Message&quot;, currentTarget.getStepname(),</span>
<span class="nc" id="L565">            data.transMeta.getName() ) );</span>
      }
<span class="nc" id="L567">    }</span>
    // alreadyMarked contains wrong steps. Spoon can report error if it will not fail transformation [BACKLOG-6753]
<span class="fc" id="L569">  }</span>

  public static void removeUnavailableStepsFromMapping( Map&lt;TargetStepAttribute, SourceStepField&gt; targetMap,
      Set&lt;SourceStepField&gt; unavailableSourceSteps, Set&lt;TargetStepAttribute&gt; unavailableTargetSteps ) {
<span class="fc" id="L573">    Iterator&lt;Entry&lt;TargetStepAttribute, SourceStepField&gt;&gt; targetMapIterator = targetMap.entrySet().iterator();</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">    while ( targetMapIterator.hasNext() ) {</span>
<span class="fc" id="L575">      Entry&lt;TargetStepAttribute, SourceStepField&gt; entry = targetMapIterator.next();</span>
<span class="fc" id="L576">      SourceStepField currentSourceStepField = entry.getValue();</span>
<span class="fc" id="L577">      TargetStepAttribute currentTargetStepAttribute = entry.getKey();</span>
<span class="pc bpc" id="L578" title="1 of 4 branches missed.">      if ( unavailableSourceSteps.contains( currentSourceStepField ) || unavailableTargetSteps.contains(</span>
          currentTargetStepAttribute ) ) {
<span class="fc" id="L580">        targetMapIterator.remove();</span>
      }
<span class="fc" id="L582">    }</span>
<span class="fc" id="L583">  }</span>

  public static Set&lt;TargetStepAttribute&gt; getUnavailableTargetSteps( Map&lt;TargetStepAttribute, SourceStepField&gt; targetMap,
      TransMeta injectedTransMeta ) {
<span class="fc" id="L587">    Set&lt;String&gt; usedStepNames = getUsedStepsForReferencendTransformation( injectedTransMeta );</span>
<span class="fc" id="L588">    Set&lt;TargetStepAttribute&gt; unavailableTargetSteps = new HashSet&lt;TargetStepAttribute&gt;();</span>
<span class="fc bfc" id="L589" title="All 2 branches covered.">    for ( TargetStepAttribute currentTarget : targetMap.keySet() ) {</span>
<span class="fc bfc" id="L590" title="All 2 branches covered.">      if ( !usedStepNames.contains( currentTarget.getStepname().toUpperCase() ) ) {</span>
<span class="fc" id="L591">        unavailableTargetSteps.add( currentTarget );</span>
      }
<span class="fc" id="L593">    }</span>
<span class="fc" id="L594">    return Collections.unmodifiableSet( unavailableTargetSteps );</span>
  }

  public static Set&lt;TargetStepAttribute&gt; getUnavailableTargetKeys( Map&lt;TargetStepAttribute, SourceStepField&gt; targetMap,
      TransMeta injectedTransMeta, Set&lt;TargetStepAttribute&gt; unavailableTargetSteps ) {
<span class="fc" id="L599">    Set&lt;TargetStepAttribute&gt; missingKeys = new HashSet&lt;&gt;();</span>
<span class="fc" id="L600">    Map&lt;String, BeanInjectionInfo&gt; beanInfos = getUsedStepBeanInfos( injectedTransMeta );</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">    for ( TargetStepAttribute key : targetMap.keySet() ) {</span>
<span class="pc bpc" id="L602" title="1 of 2 branches missed.">      if ( !unavailableTargetSteps.contains( key ) ) {</span>
<span class="fc" id="L603">        BeanInjectionInfo info = beanInfos.get( key.getStepname().toUpperCase() );</span>
<span class="pc bpc" id="L604" title="1 of 4 branches missed.">        if ( info != null &amp;&amp; !info.getProperties().containsKey( key.getAttributeKey() ) ) {</span>
<span class="fc" id="L605">          missingKeys.add( key );</span>
        }
      }
<span class="fc" id="L608">    }</span>
<span class="fc" id="L609">    return missingKeys;</span>
  }

  private static Map&lt;String, BeanInjectionInfo&gt; getUsedStepBeanInfos( TransMeta transMeta ) {
<span class="fc" id="L613">    Map&lt;String, BeanInjectionInfo&gt; res = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L614" title="All 2 branches covered.">    for ( StepMeta step : transMeta.getUsedSteps() ) {</span>
<span class="fc" id="L615">      Class&lt;? extends StepMetaInterface&gt; stepMetaClass = step.getStepMetaInterface().getClass();</span>
<span class="pc bpc" id="L616" title="1 of 2 branches missed.">      if ( BeanInjectionInfo.isInjectionSupported( stepMetaClass ) ) {</span>
<span class="fc" id="L617">        res.put( step.getName().toUpperCase(), new BeanInjectionInfo( stepMetaClass ) );</span>
      }
<span class="fc" id="L619">    }</span>
<span class="fc" id="L620">    return res;</span>
  }

  private static Set&lt;String&gt; getUsedStepsForReferencendTransformation( TransMeta transMeta ) {
<span class="fc" id="L624">    Set&lt;String&gt; usedStepNames = new HashSet&lt;String&gt;();</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">    for ( StepMeta currentStep : transMeta.getUsedSteps() ) {</span>
<span class="fc" id="L626">      usedStepNames.add( currentStep.getName().toUpperCase() );</span>
<span class="fc" id="L627">    }</span>
<span class="fc" id="L628">    return usedStepNames;</span>
  }

  public static Set&lt;SourceStepField&gt; getUnavailableSourceSteps( Map&lt;TargetStepAttribute, SourceStepField&gt; targetMap,
      TransMeta sourceTransMeta, StepMeta stepMeta ) {
<span class="fc" id="L633">    String[] stepNamesArray = sourceTransMeta.getPrevStepNames( stepMeta );</span>
<span class="fc" id="L634">    Set&lt;String&gt; existedStepNames = convertToUpperCaseSet( stepNamesArray );</span>
<span class="fc" id="L635">    Set&lt;SourceStepField&gt; unavailableSourceSteps = new HashSet&lt;SourceStepField&gt;();</span>
<span class="fc bfc" id="L636" title="All 2 branches covered.">    for ( SourceStepField currentSource : targetMap.values() ) {</span>
<span class="fc bfc" id="L637" title="All 2 branches covered.">      if ( !existedStepNames.contains( currentSource.getStepname().toUpperCase() ) ) {</span>
<span class="fc" id="L638">        unavailableSourceSteps.add( currentSource );</span>
      }
<span class="fc" id="L640">    }</span>
<span class="fc" id="L641">    return Collections.unmodifiableSet( unavailableSourceSteps );</span>
  }

  private void checkSoureStepsAvailability() {
<span class="fc" id="L645">    Map&lt;TargetStepAttribute, SourceStepField&gt; targetMap = meta.getTargetSourceMapping();</span>
<span class="fc" id="L646">    Set&lt;SourceStepField&gt; unavailableSourceSteps =</span>
<span class="fc" id="L647">        getUnavailableSourceSteps( targetMap, getTransMeta(), getStepMeta() );</span>
<span class="fc" id="L648">    Set&lt;String&gt; alreadyMarkedSteps = new HashSet&lt;String&gt;();</span>
<span class="pc bpc" id="L649" title="1 of 2 branches missed.">    for ( SourceStepField currentSource : unavailableSourceSteps ) {</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">      if ( alreadyMarkedSteps.contains( currentSource.getStepname() ) ) {</span>
<span class="nc" id="L651">        continue;</span>
      }
<span class="nc" id="L653">      alreadyMarkedSteps.add( currentSource.getStepname() );</span>
<span class="nc" id="L654">      logError( BaseMessages.getString( PKG, &quot;MetaInject.SourceStepIsNotAvailable.Message&quot;, currentSource.getStepname(),</span>
<span class="nc" id="L655">          getTransMeta().getName() ) );</span>
<span class="nc" id="L656">    }</span>
    // alreadyMarked contains wrong steps. Spoon can report error if it will not fail transformation [BACKLOG-6753]
<span class="fc" id="L658">  }</span>

  /**
   * package-local visibility for testing purposes
   */
  static Set&lt;String&gt; convertToUpperCaseSet( String[] array ) {
<span class="fc bfc" id="L664" title="All 2 branches covered.">    if ( array == null ) {</span>
<span class="fc" id="L665">      return Collections.emptySet();</span>
    }
<span class="fc" id="L667">    Set&lt;String&gt; strings = new HashSet&lt;String&gt;();</span>
<span class="fc bfc" id="L668" title="All 2 branches covered.">    for ( String currentString : array ) {</span>
<span class="fc" id="L669">      strings.add( currentString.toUpperCase() );</span>
    }
<span class="fc" id="L671">    return strings;</span>
  }

  /**
   * package-local visibility for testing purposes
   */
  TransMeta loadTransformationMeta() throws KettleException {
<span class="nc" id="L678">    return MetaInjectMeta.loadTransformationMeta( meta, getTrans().getRepository(), getTrans().getMetaStore(), this );</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>